#!/usr/bin/env bash

mkdir -p './tmp/locks'
echo '*' >./tmp/.gitignore
LOCK_FILE='./tmp/locks/flock.lock'
echo "# WARNING: Please do not edit this file manually" >$LOCK_FILE

# set 200 as the file descriptor on the lock file
# The 'exec' command can be used to modify file descriptors or execute commands in the current shell without creating a new process
# 'exec' allows you to associate a file descriptor with a file so that you can use that file descriptor in subsequent commands
# advantages of using a file descriptor on the lock file instead of directly specifying the commands to execute:
# - flock 'path/to/lockfile' -c "<commands_to_execute>" looks ugly
# - avoids the need to wrap every command (e.g., loops, conditionals, statements) inside of an individual flock command
# - the lock gets automatically released when the script exits (regardless of whether it completes successfully or exits with an error)
# - useful when combined with error handling or traps, to ensure that the lock doesn't remain held indefinitely in case of script failure
exec 200>>$LOCK_FILE

# the -n option tells flock to acquire the lock without blocking. (fail rather than wait if the lock cannot be immediately acquired)
# this means, if the lock is unavailable, flock will immediately return with a non-zero exit status
# so the if statement below will check whether the lock is available
# 'flock 200' if the lock is not available (i.e. wait till the lock is available)
if ! flock -n 200; then
    echo "Script is already running, waiting for the script execution to complete before running the current script..."
    flock 200
fi

chmod u+x ./script.sh
./script.sh
